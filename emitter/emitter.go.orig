package emitter

import (
	"fmt"

	"github.com/pspiagicw/fenc/code"
	"github.com/pspiagicw/fenc/object"
<<<<<<< HEAD
=======
	"github.com/pspiagicw/goreland"
	"maps"
	"slices"
>>>>>>> 0645c9fde7ccc64b20d275888b8226604f19b860
)

// type BuiltinFunc func(args ...object.Object) object.Object

type CompileFunc func(*Emitter) error

type ByteCode struct {
	Tape      []code.Instruction
	Constants []object.Object
}

type Emitter struct {
	tape      []code.Instruction
	tapeIndex int
	constants *ConstantPool
	symbols   *SymbolTable
<<<<<<< HEAD

	errors []error
=======
	builtins  map[string]object.Builtin
>>>>>>> 0645c9fde7ccc64b20d275888b8226604f19b860
}

func (e *Emitter) registerError(msg string, values ...any) {
	err := fmt.Errorf(msg, values...)
	e.errors = append(e.errors, err)
}

func (e *Emitter) Errors() []error {
	return e.errors
}
func (e *Emitter) enterScope() {
	e.symbols = NewEnclosedSymbolTable(e.symbols)
}
func (e *Emitter) leaveScope() {
	e.symbols = e.symbols.Outer
}
func (e *Emitter) NewSubEmitter() *Emitter {
	n := NewEmitter(e.builtins)
	n.constants = e.constants
	n.symbols = e.symbols

	return n
}

func NewEmitter(builtins map[string]object.Builtin) *Emitter {
	e := &Emitter{
		builtins:  builtins,
		constants: NewConstantPool(),
		tape:      []code.Instruction{},
		tapeIndex: 0,
		symbols:   NewSymbolTable(),
	}
	e.setupBuiltins()
	return e
}
func (e *Emitter) setupBuiltins() {
	sortedKeys := slices.Sorted(maps.Keys(e.builtins))

	for i, key := range sortedKeys {
		e.symbols.DefineBuiltin(key, i)
	}
}
func (e *Emitter) Bytecode() ByteCode {
	return ByteCode{e.tape, e.constants.constants}
}

func (e *Emitter) Emit(op code.Op, args ...int) int {
	ins := code.Instruction{
		OpCode: op,
		Args:   args,
	}
	e.tape = append(e.tape, ins)
	e.tapeIndex += 1
	return e.tapeIndex - 1
}

func (e *Emitter) Constant(o object.Object) int {
	return e.constants.Add(o)
}

func (e *Emitter) PushInt(value int) {
	o := object.CreateInt(value)
	index := e.Constant(o)
	e.Emit(code.PUSH, index)
}

func (e *Emitter) PushFloat(value float32) {
	o := object.CreateFloat(value)
	index := e.Constant(o)
	e.Emit(code.PUSH, index)
}

func (e *Emitter) PushBool(value bool) {
	o := object.CreateBool(value)
	index := e.Constant(o)
	e.Emit(code.PUSH, index)
}

func (e *Emitter) PushString(value string) {
	o := object.CreateString(value)
	index := e.Constant(o)
	e.Emit(code.PUSH, index)
}
func (e *Emitter) PushFunction(value object.Function) {
	index := e.Constant(value)
	e.Emit(code.PUSH, index)
}

func (e *Emitter) If(cond, consequence, alternative CompileFunc) error {

	// Emit the condition
	err := cond(e)
	if err != nil {
		return err
	}

	condPos := e.Emit(code.JUMP_FALSE, 0)

	err = consequence(e)
	if err != nil {
		return err
	}

	jumpEndPos := -1
	if alternative != nil {
		jumpEndPos = e.Emit(code.JUMP, 0)
	}

	e.Patch(condPos)

	if alternative != nil {
		err = alternative(e)
		if err != nil {
			return err
		}

		e.Patch(jumpEndPos)
	}

	return nil

}
func (e *Emitter) Return() {
	e.Emit(code.RETURN)
}

func (e *Emitter) Patch(jumpPos int) {
	ins := e.tape[jumpPos]
	if ins.OpCode != code.JUMP && ins.OpCode != code.JUMP_FALSE {
		e.registerError("Given instructions is not jump instruction.")
	}

	ins.Args = []int{e.tapeIndex}

	e.tape[jumpPos] = ins
}

func (e *Emitter) Store(name string) {
	s := e.symbols.Define(name)
	switch s.Scope {
	case GLOBAL_SCOPE:
		e.Emit(code.STORE_GLOBAL, s.Index)
	case LOCAL_SCOPE:
		e.Emit(code.STORE_LOCAL, s.Index)
	}
}

func (e *Emitter) Load(name string) bool {
	s, ok := e.symbols.Resolve(name)
	if !ok {
		e.registerError("Can't find symbol: %s", name)
	}

	switch s.Scope {
	case GLOBAL_SCOPE:
		e.Emit(code.LOAD_GLOBAL, s.Index)
	case LOCAL_SCOPE:
		e.Emit(code.LOAD_LOCAL, s.Index)
	case FREE_SCOPE:
		e.Emit(code.LOAD_FREE, s.Index)
	case BUILTIN_SCOPE:
		e.Emit(code.BUILTIN, s.Index)

	}

	return nil
}

func (e *Emitter) Function(name string, args []string, body CompileFunc) error {
	funcEmitter := e.NewSubEmitter()
	funcEmitter.enterScope()

	for _, arg := range args {
		funcEmitter.symbols.Define(arg)
	}

	err := body(funcEmitter)
	if err != nil {
		return err
	}

	freeSymbols := funcEmitter.symbols.Free
	funcEmitter.leaveScope()

	for _, s := range freeSymbols {
		e.Load(s.Name)
	}

	fn := object.Function{
		Value: funcEmitter.tape,
	}
	// e.PushFunction(fn)
	index := e.Constant(fn)
	e.Emit(code.CLOSURE, index, len(freeSymbols))
	e.Store(name)

	return nil
}

func (e *Emitter) Lambda(args []string, body CompileFunc) error {
	funcEmitter := e.NewSubEmitter()
	funcEmitter.enterScope()

	for _, arg := range args {
		funcEmitter.symbols.Define(arg)
	}

	err := body(funcEmitter)
	if err != nil {
		return err
	}

	freeSymbols := funcEmitter.symbols.Free
	funcEmitter.leaveScope()

	for _, s := range freeSymbols {
		e.Load(s.Name)
	}

	fn := object.Function{
		Value: funcEmitter.tape,
	}
	// e.PushFunction(fn)
	index := e.Constant(fn)
	e.Emit(code.CLOSURE, index, len(freeSymbols))

	return nil
}

func (e *Emitter) Class(name string) {
	e.PushString(name)

	e.Emit(code.CLASS)
}
func (e *Emitter) Array(count int) {
	e.Emit(code.ARRAY, count)
}
func (e *Emitter) Hash(count int) {
	e.Emit(code.HASH, count)
}

func (e *Emitter) Index() {
	e.Emit(code.INDEX)
}
func (e *Emitter) Access() {
	e.Emit(code.ACCESS)
}
func (e *Emitter) ReturnValue() {
	e.Emit(code.RETURN_VALUE)
}

func (e *Emitter) Call(args int) {
	e.Emit(code.CALL, args)
}

func (e *Emitter) AddInt() {
	e.Emit(code.ADD_INT)
}
func (e *Emitter) SubInt() {
	e.Emit(code.SUB_INT)
}
func (e *Emitter) MulInt() {
	e.Emit(code.MUL_INT)
}
func (e *Emitter) DivInt() {
	e.Emit(code.DIV_INT)
}

func (e *Emitter) LtInt() {
	e.Emit(code.LT_INT)
}
func (e *Emitter) LteInt() {
	e.Emit(code.LTE_INT)
}
func (e *Emitter) GtInt() {
	e.Emit(code.GT_INT)
}
func (e *Emitter) GteInt() {
	e.Emit(code.GTE_INT)
}

func (e *Emitter) Eq() {
	e.Emit(code.EQ)
}
func (e *Emitter) Neq() {
	e.Emit(code.NEQ)
}

func (e *Emitter) AddFloat() {
	e.Emit(code.ADD_FLOAT)
}
func (e *Emitter) SubFloat() {
	e.Emit(code.SUB_FLOAT)
}
func (e *Emitter) MulFloat() {
	e.Emit(code.MUL_FLOAT)
}
func (e *Emitter) DivFloat() {
	e.Emit(code.DIV_FLOAT)
}

func (e *Emitter) LtFloat() {
	e.Emit(code.LT_FLOAT)
}
func (e *Emitter) LteFloat() {
	e.Emit(code.LTE_FLOAT)
}
func (e *Emitter) GtFloat() {
	e.Emit(code.GT_FLOAT)
}
func (e *Emitter) GteFloat() {
	e.Emit(code.GTE_FLOAT)
}

func (e *Emitter) AndBool() {
	e.Emit(code.AND_BOOL)
}
func (e *Emitter) OrBool() {
	e.Emit(code.OR_BOOL)
}

func (e *Emitter) AddString() {
	e.Emit(code.ADD_STRING)
}

func (e *Emitter) ToFloat() {
	e.Emit(code.TO_FLOAT)
}
